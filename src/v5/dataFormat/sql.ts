import { NonManyToManyRelationList, Relation, RelationType } from '../relations/types'
import { DataType, EpochSubType, JsonSubType, NumSubType, StrSubType, ThreeStepNumberSize, TwoStepNumberSize } from './types/dataType'
import { Field, FieldList } from './types/field'

const NUMBER_SIZE_TYPE_NAME_MAPPING = {
  [NumSubType.INT]: {
    [ThreeStepNumberSize.SMALL]: 'smallint',
    [ThreeStepNumberSize.REGULAR]: 'integer',
    [ThreeStepNumberSize.LARGE]: 'bigint',
  },
  [NumSubType.REAL]: {
    [TwoStepNumberSize.REGULAR]: 'real',
    [TwoStepNumberSize.LARGE]: 'double precision',
  },
  [NumSubType.SERIAL]: {
    [ThreeStepNumberSize.SMALL]: 'smallserial',
    [ThreeStepNumberSize.REGULAR]: 'serial',
    [ThreeStepNumberSize.LARGE]: 'bigserial',
  },
}

const DATE_TYPE_NAME_MAPPING = {
  [EpochSubType.DATE_TIME_WITH_TIMEZONE]: 'timestamp with time zone',
  [EpochSubType.DATE_TIME]: 'timestamp',
  [EpochSubType.DATE]: 'date',
  [EpochSubType.TIME]: 'time',
}

const createBoolColumnSql = (field: Field<DataType.BOOL>, isUnique: boolean): string => {
  const columnName = field.sql.columnName

  return [
    `${columnName} boolean`,
    field.allowNull ? '' : 'not null',
    isUnique ? 'unique' : '',
    field.default != null
      ? field.default
        ? 'default true'
        : 'default false'
      : '',
  ].filter(s => s.length > 0).join(' ')
}

const createNumColumnSql = (field: Field<DataType.NUM>, isUnique: boolean): string => {
  const columnName = field.sql.columnName
  const isReal = field.subType === NumSubType.REAL
  const isEnum = field.subType === NumSubType.INT_ENUM
  const size = isEnum
    ? ThreeStepNumberSize.SMALL
    : (field.size ?? (isReal ? TwoStepNumberSize.REGULAR : ThreeStepNumberSize.REGULAR))

  const typeName = isEnum
    ? NUMBER_SIZE_TYPE_NAME_MAPPING[NumSubType.INT][size]
    // `subType` enforces that `size` will always be correct here.
    // @ts-ignore
    : NUMBER_SIZE_TYPE_NAME_MAPPING[field.subType][size]

  const isSerial = field.subType === NumSubType.SERIAL
  const isPrimaryKey = !isReal && (field.isPrimaryKey ?? isSerial)
  const allowNull = !isPrimaryKey && !isSerial && (field.allowNull ?? true)

  return [
    `${columnName} ${typeName}`,
    // Not null text
    allowNull ? null : 'not null',
    // Serial text
    isPrimaryKey ? 'primary key' : null,
    // Unique text
    isUnique ? 'unique' : null,
    // Default text
    isSerial
      ? null
      : field.default != null
        ? `default ${field.default}`
        : null,
  ].filter(s => s != null && s.length > 0).join(' ')
}

const getStringColumnTypeName = (field: Field<DataType.STR>): string => {
  switch (field.subType) {
    case StrSubType.VAR_LENGTH:
      return `character varying(${field.maxLen})`
    case StrSubType.FIXED_LENGTH:
      return `character(${field.len})`
    case StrSubType.ENUM:
      return `character varying(${field.maxLen ?? 100})`
    case StrSubType.UUID_V4:
      return 'character(36)'
    default:
      return null
  }
}

const createStrColumnSql = (field: Field<DataType.STR>, isUnique: boolean): string => {
  const columnName = field.sql.columnName
  const typeName = getStringColumnTypeName(field)

  const isAutoGenerated = field.subType === StrSubType.UUID_V4 && (field.autoGenerate ?? true)

  return [
    `${columnName} ${typeName}`,
    // Not null text
    (field.allowNull ?? false) ? null : 'not null',
    isUnique ? 'unique' : null,
    // Default text
    field.default != null && !isAutoGenerated ? `default '${field.default}'` : null,
    // Uuid-v4-specific text
    isAutoGenerated
      ? 'default uuid_generate_v4()'
      : null,
  ].filter(s => s != null && s.length > 0).join(' ')
}

const createEpochColumnSql = (field: Field<DataType.EPOCH>, isUnique: boolean): string => {
  const columnName = field.sql.columnName
  const typeName = DATE_TYPE_NAME_MAPPING[field.subType]

  return [
    `${columnName} ${typeName}`,
    // Not null text
    (field.allowNull ?? true) ? null : 'not null',
    // Unique text
    isUnique ? 'unique' : null,
    // Default text
    field.defaultToCurrentEpoch
      ? 'default CURRENT_TIMESTAMP'
      : field.default != null
        ? `default ${field.default}`
        : null,
  ].filter(s => s != null && s.length > 0).join(' ')
}

const createJsonColumnSql = (field: Field<DataType.JSON>, isUnique: boolean): string => {
  const columnName = field.sql.columnName
  const isArray = field.subType === JsonSubType.ARRAY
  const allowNull = field.allowNull ?? false

  return [
    `${columnName} jsonb`,
    // Not null text
    allowNull ? null : 'not null',
    // Unique text
    isUnique ? 'unique' : null,
    // Default text
    field.default != null
      ? `default '${JSON.stringify(field.default)}'::jsonb`
      : `default '${isArray ? '[]' : '{}'}'::jsonb`,
  ].filter(s => s != null && s.length > 0).join(' ')
}

const createColumnSql = (field: Field, isUnique: boolean): string => {
  switch (field.type) {
    case DataType.NUM:
      return createNumColumnSql(field, isUnique)
    case DataType.BOOL:
      return createBoolColumnSql(field, isUnique)
    case DataType.STR:
      return createStrColumnSql(field, isUnique)
    case DataType.EPOCH:
      // @ts-ignore TODO: Not sure why this is failing
      return createEpochColumnSql(field, isUnique)
    case DataType.JSON:
      return createJsonColumnSql(field, isUnique)
    default:
      return null
  }
}

const createColumnsSql = (
  fieldList: FieldList,
  oneToOneRelations: Relation<RelationType.ONE_TO_ONE>[],
): string => (
  fieldList
    .map(f => createColumnSql(f, oneToOneRelations.some(r => r.toOneField.field === f.name)))
    .join(',\n  ')
)

const createForeignKeysSql = (
  relations: Relation<RelationType.ONE_TO_MANY | RelationType.ONE_TO_ONE>[],
): string => (
  relations
    .map(r => r.sql.foreignKeySql)
    .join(',\n')
)

export const createTableSql = (
  dataFormatTableName: string,
  fieldList: FieldList,
  relations?: NonManyToManyRelationList,
) => {
  const oneToOneRelations = relations
    ?.filter(r => r.type === RelationType.ONE_TO_ONE) as Relation<RelationType.ONE_TO_ONE>[] ?? []
  const columnsSql = createColumnsSql(fieldList, oneToOneRelations)
  const foreignKeysSql = relations != null ? createForeignKeysSql(relations) : ''

  return `create table if not exists public.${dataFormatTableName}
(
  ${[columnsSql, foreignKeysSql].filter(s => s != null && s.length > 0).join(',\n')}
)

tablespace pg_default;

alter table if exists public.${dataFormatTableName}
  owner to postgres;`
}
